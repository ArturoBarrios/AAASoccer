type Query {
  allEvents(type: EventType): [Event!]  
  allGames(pickup: Boolean): [Game!]  
  allTrainings: [Training!]  
  allTryouts: [Tryout!]  
  allLeagues: [League!]  
  allTournaments: [Tournament!]  
  allUsers: [User!]
  allPlayers: [Player!]
  allRequests: [Request!]
  allTeams: [Team!]
  getUser(email: String): User  
  AllGamesByID(ids: [ID]):[ID] @resolver
  AllEventsByID(ids: [ID]):[ID] @resolver
}



enum RoleType {
  COACH
  PLAYER
  REFERREE
  ORGANIZER
  VOLUNTEER
  SPONSOR
}

enum EventType {
  TRYOUT
  GAME
  LEAGUE
  TOURNAMENT
  TRAINING
}

enum MessageType {
  TEXT
  IMAGE
  VIDEO
  AUDIO
}


enum SurfaceType {
  TURFPOOR
  TURFOKAY
  TURFGOOD
  TURFEXCELLENT
  GRASSPOOR
  GRASSOKAY
  GRASSGOOD
  GRASSEXCELLENT
  HARDFLOOR
  SAND
  NAILS
  QUICKSAND
}

enum FieldPlayerOccupancySize {
  SMALL
  MEDIUM
  FULLSIZE
}

enum GenderType {
  MALE
  FEMALE
}

enum ModelType {
  USER
  ORGANIZATION
  EVENT
}

enum UserAccountStatus{
  UNCOMFIRMED
  CONFIRMED
  INACTIVE
  BANNED
}

enum RequestStatus{
  PENDING
  ACCEPTED
  REJECTED
}
enum UserType{
  PLAYER
  ORGANIZER
  MANAGER
  MAINCOACH
  ASSISTANTCOACH
  REF
}

enum RequestType{
  FRIENDREQUEST
  GAMEREQUEST
  TEAMREQUEST
  TOURNAMENTREQUEST
  LEAGUEREQUEST
  TRAININGREQUEST
  TEAMEVENTREQUEST
}

type Request {
  type: RequestType
  sender: User @relation(name: "requests_sent")
  receivers: [User] @relation(name: "request_receivers")
  acceptedBy: User @relation(name: "request_acceptedBy")
  status: RequestStatus
  requestAttempts: Int
  fromOrganizer: Boolean
  event: Event
  team: Team
  forRole: String
  sentAt: Int
  acceptedAt: Int
  
}

# type FriendRequest {
#   sender: User
#   receiver: User @relation(name: "friend_requests")
#   status: RequestStatus @default(value: PENDING)
#   requestAttempts: Int @default(value: 0)
#   requestType: RequestType @default(value: FRIENDREQUEST)
# }


# # event request will be sent to event organizers
# type EventRequest {
#   organizers: [User!] @relation(name: "event_requests_organizers")  
#   sender: User @relation(name: "event_requests_sent")
#   acceptedBy: User @relation(name: "event_requests_acceptedBy")
#   receivers: [User!] @relation(name: "event_requests_to_accept")  
#   event: Event!  
#   status: RequestStatus @default(value: PENDING)
#   requestAttempts: Int @default(value: 0)  
#   requestType: RequestType @default(value: EVENTREQUEST)
# }

# # event request will be sent to team organizers
# type TeamRequest {
#   organizers: [User!] @relation(name: "team_requests_organizers")  
#   sender: User @relation(name: "team_requests_sent")
#   acceptedBy: User @relation(name: "team_requests_acceptedBy")
#   receivers: [User!] @relation(name: "team_requests_to_accept")  
#   team: Team!  
#   status: RequestStatus @default(value: PENDING)
#   requestAttempts: Int @default(value: 0)
#   requestType: RequestType @default(value: TEAMREQUEST)
# }


# type OrganizerRequest {
#   from: User!
#   to: User!
#   status: RequestStatus @default(value: PENDING)
#   requestAttempts: Int @default(value: 0)
# }

type StripeCustomer {
  customerId: String
  user: User
}

type UserLink {
   user: User     
}


type User  {  
  stripeCustomers: [StripeCustomer] @relation
  payments: [Payment] @relation
  userType: UserType
  OSPID: String
  name: String
  phone: String
  email: String
  bio: String
  username: String
  birthdate: String
  age: Int
  friends: [UserLink]! @relation(name: "user_friends")
  teams: [Team] @relation
  gender: GenderType
  location: Location
  player: Player
  organizer: Organizer
  coach: Coach
  referee: Referee
  status: UserAccountStatus
  last_login: Int
  last_updated: Int
  images: [Image] @relation
  events: [Event] @relation      
  eventUserParticipants: [EventUserParticipant] @relation   
  teamUserParticipants: [TeamUserParticipant] @relation  
  requestsSent: [Request]  @relation(name: "requests_sent")
  requestsReceived: [Request] @relation(name: "request_receivers")
  requestsAccepted: [Request] @relation(name: "request_acceptedBy")
  chats: [Chat] @relation(name: "user_chats")
  sentMessages: [Message] @relation(name: "messages_sent")
  messagesDirectedForMe: [Message] @relation(name: "messages_for")
  onboarded: Boolean @default(value: false)
}


type Player   {  
  wagerRating: String
  wagers: [Wager] @relation  
  # events: [Event] @relation  
  competitiveLevel: String
  ratings: String
  hasRating: String
  showRating: String
  hasSubscription: String
  user: User
  selfRating: Int
  sponsors: [Sponsor] @relation
  # games: [Game] @relation  
}

type EventUserParticipant {
  event: Event
  user: User
  roles: String
}

type TeamUserParticipant {
  team: Team
  user: User
  roles: String
}

type Game {
  hometeam: Team
  awayTeam: Team
  teamA: String 
  teamB: String
  round: Int
  gameNumber: Int
  homegoals: Int
  awaygoals: Int
  pickup: Boolean
  event: Event  
}

type JoinConditions {
  withRequest: Boolean
  withPayment: Boolean  
  events: Event
}

type Event   {
  name: String
  joinConditions: JoinConditions
  isMainEvent: Boolean
  userParticipants: [EventUserParticipant] @relation
  # eventUserOrganizers: EventUserOrganizers
  price: Price    
  request: [Request] @relation
  # organization: Organization
  #need org to create events? nah. allow user to create events,
  #if user has orgs, they can select which org to create event for                
  coorganizations: [Organization] @relation
  sponsors: [Sponsor] @relation
  # creator: User 
  ratings: [Rating] @relation
  images: [Image] @relation
  location: [Location] @relation
  type: EventType
  payments: [Payment] @relation
  chats: [Chat] @relation
  # training: Training
  # tournament: Tournament
  # league: League
  # tryout: Tryout
  teams: [Team] @relation
  games: [Game] @relation
  users: [User] @relation  
  #I don't  think you need these since tournament 
  #can have many events but not the other way around
  # tournament: Tournament 
  tryouts: [Tryout] @relation
  leagues: [League]  @relation
  tournaments: [Tournament] @relation
  trainings: [Training] @relation 
  wager: [Wager] @relation  
  archived: Boolean  @default(value: false)
  deleted: Boolean  @default(value: false)
  startTime: String
  endTime: String
  createdAt: String
}

type Team   {
  name: String!
  color: String!  
  events: [Event] @relation
  images: [Image] @relation
  users: [User] @relation    
  sponsors: [Sponsor] @relation
  location: Location    
  userParticipants: [TeamUserParticipant] @relation
  status: String
  deleted: Boolean
  createdAt: Int
  request: [Request] @relation
  chats: [Chat] @relation
  
}

type Coach   {  
  user: User
}

type Referee   {  
  user: User
}

type Organizer   {  
  user: User
}


# a payment is attached to event
# use payment object to create payment screen details for event
type Payment   {  
  amount: String
  event: Event
  paidAt: String
  user: User
}

# orgs can have many suborgs
# allow org to behave as Sponsor
type Organization   {  
  name: String
  images: [Image] @relation
  rating: String
  events: [Event] @relation
  # suborgs: [Organization] @relation
  # sponsor: Sponsor
  sponsors: [Sponsor] @relation
  description: String
  minAge: Int
  maxAge: Int
  inviteOnly: Boolean
  private: Boolean #it won't show up in public search
  isMainOrg: Boolean
}

# sponsor is an org
type Sponsor {
  id: ID!
  name: String
  images: [Image] @relation
  description: String
  url: String
  event: [Event] @relation  
  sponsoredOrgs: [Organization] @relation
  sponsoredPlayers: [Player] @relation
  sponsoredTeams: [Team] @relation
}

type Wager   {  
  name: String
  amount: String
  players: [Player] @relation
  # eligibleEventTypes: [EventType] @relation
  private: Boolean
  events: [Event] @relation
}


type Tryout   {  
  # event: Event
  event: Event
  #tryout can have a pickup game
  # eligibleEventTypes: [EventType] @relation
}

type League   {  
  tournament: Tournament    
  # event: Event
  events: [Event] @relation
  numberOfTeams: Int
  # eligibleEventTypes: [EventType] @relation
}

type Tournament   {
  groupPlay: Boolean  
  # event: Event
  events: [Event] @relation
  numberOfTeams: Int
  # eligibleEventTypes: [EventType] @relation  
}

type Training   {  
  event: Event  
  # eligibleEventTypes: [EventType] @relation
}


type Image   {  
  isMainImage: Boolean
  public: Boolean
  url: String
  key: String
  user: User
  event: Event
  team: Team
  location: Location
  organization: Organization
  attachedModelType: ModelType
  sponsor: Sponsor   
  s3bucket: String 
}

type GifContent   {
  gifUrl: String
}

type TextContent   {
  content: String
}

type Message {  
  chatObject: Chat #belongs to chat
  textObject: TextContent
  gifObject: GifContent
  imageObject: Image
  sender: User @relation(name: "messages_sent") 
  messageType: MessageType
  for: [User] @relation(name: "messages_for")
}

type Chat  {  
  name: String
  messages: [Message] @relation #has many messages
  users: [User] @relation(name: "user_chats")
  event: Event
  team: Team
  archived: Boolean @default(value: false)
}

type AppSubscription   {
  id: ID!
  tier: String
}

type Location   {  
  name: String
  secondaryName: String
  address: String
  surface: SurfaceType
  images: [Image] @relation
  fieldSize: FieldPlayerOccupancySize
  private: Boolean
  schedule: String
  latitude: Float!
  longitude: Float!
  events: [Event] @relation
  user: User
  team: Team
}

type Rating   {
  id: ID!
  event: Event
}

type Price   {  
  amount: String
  event: Event
}
